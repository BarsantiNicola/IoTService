package rest.out.beans;

//  internal services
import rest.msg.RESTMessage;
import rest.msg.out.req.ExecCommandsReq;

//  executors
import java.util.concurrent.Callable;

//  jersey REST management
import org.glassfish.jersey.client.ClientProperties;
import org.glassfish.jersey.client.HttpUrlConnectorProvider;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.Entity;
import javax.ws.rs.core.*;


/**
 * Class in charge of sending the messages via the Jersey REST interface. The class
 * is able to use http methods GET,PUT,POST,PATCH and DELETE and to forward back the
 * destination responses. The object is developed as Callable to permit fast parallelization and control(by ExecutorService).
 * This is done because we have two levels of parallelization:
 *  - multiple REST messages by different clients/components -> parallelization generated by Stateless services which call RESTsender
 *  - fake multicast of multiple requests inside each message(each message can carry multiple requests to
 *  be done atomically) -> parallelization generated by ExecutorService to send immediately each atomic request without waiting
 *  the previous
 */
public class RESTsender implements Callable<Response> {

    private final String address;       //  destination of the communication
    private final int port;             //  port used by the destination
    private final String path;          //  destination path for the request
    private final REQ_TYPE reqType;     //  http method to be sued
    private final RESTMessage request;  //  request to be forwarded

    //  http method supported
    public enum REQ_TYPE{
        GET,
        PUT,
        POST,
        PATCH,
        DELETE
    }

    RESTsender( String address, int port, String path, REQ_TYPE reqType, RESTMessage request ){

        this.address = address;
        this.port = port;
        this.request = request;
        this.path = path;
        this.reqType = reqType;

    }

    @Override
    public Response call() {

        try {
            switch (this.reqType) {

                case GET:
                    return ClientBuilder
                            .newClient()
                            .property(ClientProperties.CONNECT_TIMEOUT, 5000)   //  preventing never ending wait
                            .target("http://" + this.address + ":" + this.port) //  destination address
                            .path(path)                                            //  relative path for the request
                            .request()
                            .get();

                case PUT:
                    return ClientBuilder
                            .newClient()
                            .property(ClientProperties.CONNECT_TIMEOUT, 5000)   //  preventing never ending wait
                            .target("http://" + this.address + ":" + this.port) //  destination address
                            .path(path)                                            //  relative path for the request
                            .request(MediaType.APPLICATION_JSON)                   //  always send a json as body
                            .put(Entity.entity(request, MediaType.APPLICATION_JSON));

                case POST:
                    return ClientBuilder
                            .newClient()
                            .property(ClientProperties.CONNECT_TIMEOUT, 5000)   //  preventing never ending wait
                            .target("http://" + this.address + ":" + this.port) //  destination address
                            .path(path)                                            //  relative path for the request
                            .request(MediaType.APPLICATION_JSON)                   //  always send a json as body
                            .post(Entity.entity(request, MediaType.APPLICATION_JSON));

                case DELETE:
                    return ClientBuilder
                            .newClient()
                            .property(ClientProperties.CONNECT_TIMEOUT, 5000)    //  preventing never ending wait
                            .target("http://" + this.address + ":" + this.port)  //  destination address
                            .path(path)                                             //  relative path for the request
                            .request(MediaType.APPLICATION_JSON)                    //  always send a json as body
                            .delete();

                case PATCH:
                    return ClientBuilder
                            .newClient()
                            .property(ClientProperties.CONNECT_TIMEOUT, 5000)    //  preventing never ending wait
                            .target("http://" + this.address + ":" + this.port)  //  destination address
                            .path(path)                                             //  relative path for the request
                            .request(MediaType.APPLICATION_JSON)                    //  always send a json as body
                            .build(
                                    "PATCH",
                                    Entity.entity(((ExecCommandsReq) request).getRequests(), MediaType.APPLICATION_JSON))
                            .property(HttpUrlConnectorProvider.SET_METHOD_WORKAROUND, true)  //  force Jersey to use PATCH
                            .invoke();

                default:
                    return Response.serverError().build();

            }
        }catch( Exception e ){
            return Response.serverError().build();
        }

    }

}
